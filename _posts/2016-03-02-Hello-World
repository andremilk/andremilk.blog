---
published: false
layout: post
---


What is the Hello World equivalent of docker containers? Let's find out.

## Hello World

Docker allows you to run applications inside it's containers with a simple command line. 

	[dekozo@dekarch ~]$ docker run ubuntu:14.04 /bin/echo "Hello World"
	Hello World
	[dekozo@dekarch ~]$ 

What the command above did was to create a container using an image called ubuntu with the tag 14.04 (I'll explain that later) and then run the __/bin/echo__ command inside it with "Hello World" as it's parameter.

Ok, if that did not amaze you check this out:

	[dekozo@dekarch ~]$ time docker run ubuntu:14.04 /bin/echo "Hello World"
	Hello World

	real	0m0.979s
	user	0m0.040s
	sys	0m0.003s
	[dekozo@dekarch ~]$ 
    
That's one of the many beauties of containers.. they are fast. The first talk I gave about Docker at university a professor didn't quite believe it wasn't fake. He was used to launching VMs, waiting for it to provision and then boot.. that was a surprise for him.

The command above will search for the ubuntu image locally and if, not found, download it from the dockerhub (or another registry if configured to do so). If you already have the image available locally the command shouldn't take long but if not it will take some time but the next time you use the same image it will be very fast.

Now let's try something different

	[dekozo@dekarch ~]$ docker run -it --rm ubuntu:14.04 /bin/bash
	root@7f31c91fe7e3:/# 

Now you are running a bash session inside a container you've just created. You might wanna play around a bit.. check all the processes running inside the container, the files and verify that they are different from your host system.
After that you could exit the container with **Ctrl-D** which will exit it and change the container's status to exited (actually, in this case we used the **__--rm__** flag to autoremove the container after it's exited) or you could get out of it with **Ctrl-P Ctrl-Q** and it will still be running. 

In the last command we also used the **__--it__** flag which enabled us to interact with the container. For further details you should check the docker documentation for the run command.. there you will find more about these flags.

Everytime we create a container in docker and don't name it ourselves a random name will be given to it. This name will consist an adjective, an underscore, and the name of some scientist. (__fun fact: if the combination yield [boring_wozniak](https://github.com/docker/docker/blob/master/pkg/namesgenerator/names-generator.go) docker will reassign another name to the container__)

Let's see our containers:

	[dekozo@dekarch ~]$ docker ps -a
	CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES
	ff3e9e82ff5d        ubuntu:14.04        "/bin/echo 'Hello Wor"   3 seconds ago       Exited (0) 2 seconds ago                       berserk_mclean
	[dekozo@dekarch ~]$ 
    
 The **[docker ps](https://docs.docker.com/engine/reference/commandline/ps/)** command will list our containers. If no option is given it will only list running containers. To see containers in different states other than running we must use the flag __-a__ just like in the example above. There are some ways to filter our results and to format it differently.

Our container was named beserk_mclean ([Malcolm McLean](https://en.wikipedia.org/wiki/Malcom_McLean), the inventor of the modern shipping container) but what if I want to name my container differently?

	[dekozo@dekarch ~]$ docker run -it --name my-container ubuntu:14.04 /bin/bash
	root@fd7705e2aeb9:/# exit
	[dekozo@dekarch ~]$ docker start my-container 
	my-container
	[dekozo@dekarch ~]$ docker attach my-container 
	root@fd7705e2aeb9:/# 
    **Ctrl-P Ctrl-Q**

Here we created a container named __my-container__ and started a bash session which we then exited. 
We started our just exited container with the **docker start** command and then proceeded to attach to it with **docker attach**.
After that we started again our container.

One way to verify that what happens inside a container does not reflect our host system is doing so:

	[dekozo@dekarch ~]$ docker exec my-container /bin/bash -c "echo 'INSIDE MY-CONTAINER' >> /tmp/foo"
	[dekozo@dekarch ~]$ echo 'OUTSIDE MY-CONTAINER' >> /tmp/foo
	[dekozo@dekarch ~]$ docker exec my-container /bin/bash -c "cat /tmp/foo"
	INSIDE MY-CONTAINER
	[dekozo@dekarch ~]$ cat /tmp/foo
	OUTSIDE MY-CONTAINER
	[dekozo@dekarch ~]$ 
    
The **docker exec** command will execute some given command inside a running container. In our case we just used it to create a file __/tmp/foo__ inside the container with the text to indicate that it was inside the container. We then created the __same file__ outside the container with a different text.

But what if I want to copy a file inside the container to my host system? Or the other way around?

	[dekozo@dekarch ~]$ docker cp my-container:/tmp/foo /tmp/foo-outside
	[dekozo@dekarch ~]$ docker cp /tmp/foo my-container:/tmp/foo-inside
	[dekozo@dekarch ~]$ cat /tmp/foo-outside 
	INSIDE MY-CONTAINER
	[dekozo@dekarch ~]$ docker exec my-container /bin/bash -c "cat /tmp/foo-inside"
	OUTSIDE MY-CONTAINER
	[dekozo@dekarch ~]$
    
The **docker cp** command will circumvent the isolation between the host and the container. **(To reference files inside the container we should use container_name:/path/to/file)**.

There are a handful of commands to be used on the docker client and you can find them all listed [here](https://docs.docker.com/engine/reference/commandline/), but just to mention a few:

	$ docker inspect my-container
    
will inspect the metadata of our container

	$ docker logs -f my-container

will display the logs (and follow it, just like a __tail -f__ would) of our container

	$ docker rename old-name new-name 
    
will rename our container

	$ docker stats my-container
    
will display some of the resources usage of our container.. you could also check **docker top** out.

The last command on this session will enable us to delete containers. 

Let's check what containers we have so far:

	[dekozo@dekarch ~]$ docker ps -a
	CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES
	fd7705e2aeb9        ubuntu:14.04        "/bin/bash"              19 minutes ago      Up 19 minutes                                   my-container
	ff3e9e82ff5d        ubuntu:14.04        "/bin/echo 'Hello Wor"   24 minutes ago      Exited (0) 24 minutes ago                       berserk_mclean
	[dekozo@dekarch ~]$
    
Ok, we have two containers: __my-container__ and __beserk_mclean__. Let's remove them!

	[dekozo@dekarch ~]$ docker rm -f my-container berserk_mclean 
	my-container
	berserk_mclean
	[dekozo@dekarch ~]$ 


If you check it with  **docker ps -a** you should see there are no more containers. We used the option __-f__ to force docker to remove our running container. If we used just **docker rm my-container berserk_mclean** docker would complain about a running container and asks us to either terminate it or use __-f__.
